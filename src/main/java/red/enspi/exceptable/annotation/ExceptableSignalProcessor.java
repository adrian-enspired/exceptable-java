/*
 * author     Adrian <adrian@enspi.red>
 * copyright  2024
 * license    GPL-3.0 (only)
 *
 *  This program is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License, version 3.
 *  The right to apply the terms of later versions of the GPL is RESERVED.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with this program.
 *  If not, see <http://www.gnu.org/licenses/gpl-3.0.txt>.
 */
package red.enspi.exceptable.annotation;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.SourceVersion;
import javax.tools.Diagnostic;

@SupportedAnnotationTypes("red.enspi.exceptable.annotation.ExceptableSignal")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class ExceptableSignalProcessor extends AbstractProcessor {

  public static String template = """
    /** _Exceptable_ generated by red.enspi.exceptable.annotation.@ExceptableSignal */
    package {package};

    import {package}.{signalClassname};

    import red.enspi.exceptable.Exceptable;
    import red.enspi.exceptable.signal.Error;

    public class {exceptableClassname}
      extends {extendsFrom}
      implements {exceptableInterface} {

      private final Exceptable.Signal signal;
      private final Exceptable.Signal.Context context;

      public {exceptableClassname}() {
        this(Error.UnknownError, null, null);
      }

      public {exceptableClassname}(Signal signal, Signal.Context context, Throwable cause) {
        super(
          (signal != null) ? signal.message(context) : Error.UnknownError.message(context),
          cause);
        this.signal = (signal != null) ? signal : Error.UnknownError;
        this.context = context;
      }

      @Override
      public Signal.Context context() { return this.context; }

      @Override
      public Signal signal() { return this.signal; }
    }

    """;

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    var messager = this.processingEnv.getMessager();
    for (var annotationElement : annotations) {
      for (Element element : roundEnv.getElementsAnnotatedWith(annotationElement)) {
        if (! this.shouldProcess(element)) {
          continue;
        }
        var annotation = element.getAnnotation(ExceptableSignal.class);
        messager.printMessage(
          Diagnostic.Kind.NOTE,
          String.format("Generating Exceptable for %s...", element.getSimpleName()),
          element);
        var packageName = this.findPackage(element);
        var exceptablePackageName = annotation.exceptablePackageName();
        if (exceptablePackageName == null) {
          exceptablePackageName = packageName;
        }
        var signalClassname = element.getSimpleName().toString();
        var exceptableClassname = signalClassname + "Exception";
        var subs = new HashMap<String, String>();
        subs.put("{package}", packageName);
        subs.put("{signalClassname}", signalClassname);
        subs.put("{extendsFrom}", annotation.extendsFrom());
        subs.put("{exceptableInterface}", annotation.exceptableInterface());
        subs.put("{exceptableClassname}", exceptableClassname);
        var source = ExceptableSignalProcessor.template;
        for (var sub : subs.entrySet()) {
          source = source.replace(sub.getKey(), sub.getValue());
        }
        try (
          Writer writer = processingEnv.getFiler()
            .createSourceFile(packageName + "." + exceptableClassname)
            .openWriter()
        ) {
          writer.write(source);
        } catch (IOException e) {
          messager.printMessage(
            Diagnostic.Kind.ERROR,
            "Code generation failed: " + e.getMessage(),
            element);
          return false;
        }
      }
    }
    return true;
  }

  private String findPackage(Element element) {
    while (element.getEnclosingElement() instanceof Element enclosingElement) {
      if (enclosingElement instanceof PackageElement packageElement) {
        return packageElement.getQualifiedName().toString();
      }
      element = enclosingElement;
    }
    return "red.enspi.exceptable";
  }

  private boolean shouldProcess(Element element) {
    return (element.getKind().isClass())
      && this.processingEnv.getTypeUtils().isSubtype(
        element.asType(),
        this.processingEnv
          .getElementUtils()
          .getTypeElement("red.enspi.exceptable.Exceptable.Signal")
          .asType());
  }
}
